<!--
   
   Copyright (c) 2020, the Regular Table Authors.
   
   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../dist/umd/regular-table.js"></script>
    <link rel='stylesheet' href="../dist/css/material.css">
</head>

<body>

    <regular-table></regular-table>

    <script>
        
        class CreateDataModel {
            constructor(base_columns, column_count, cell_count) {
                this._base_columns = base_columns;
                this._column_count = column_count;
                this._cell_count = cell_count;
                this._dataset = this._create_dataset();
                this.columns = this._create_columns();
                this._data = this.columns.map(({ key }) => this._dataset[key]);
                this._column_headers = this.columns.map(({ value }) => [value]);
            }

            _create_text_cells(text) {
                return Array.from(Array(this._cell_count).keys()).map(idx => `${text} ${idx}`);
            }
                    
            _create_columns() {
                return Array.from(Array(this._column_count)).map((_, idx) => {
                    const key = this._base_columns[idx % this._base_columns.length];
                    return { 
                        key,
                        value: `${key} Column ${idx}`
                    };
                });
            }

            _create_dataset() {
                return this._base_columns.reduce((prev, curr) => ({
                    ...prev,
                    [curr]: this._create_text_cells(curr)
                }), {});
            }

            data_listener = (x0, y0, x1, y1) => {
                const data = this._data.slice(x0, x1).map(col => col.slice(y0, y1));
                const column_headers = this._column_headers.slice(x0, x1);
                const num_columns = this._data.length;
                const num_rows = this._data[0].length;
                return {
                    num_rows,
                    num_columns,
                    column_headers,
                    data
                };
            };
        }

        const BASE_COLUMNS = ['Fixed', 'Not Set'];
        const COLUMN_COUNT = 20;
        const CELL_COUNT = 1000;

        // Create a data model that returns a data_listener function and a columns array.
        const data_model = new CreateDataModel(
            BASE_COLUMNS,
            COLUMN_COUNT,
            CELL_COUNT
        );

        // Get Regular Table element.
        const table_api = document.getElementsByTagName('regular-table')[0];
        const FIXED_CLASS = 'fixed';

        // Clear previous cell manipulations done by this api.
        function clear(cellElement) {
            cellElement.classList.remove(FIXED_CLASS);
            cellElement.style.minWidth = '';
        }

        function get_column_name(index) {
            return data_model.columns[index].key;
        }

        // Check if cell should apply fixed min-width.
        function is_fixed(cellElement) {
            // Use regular-table api to get cell metadata.
            const metadata = table_api.get_meta(cellElement);
            const name = get_column_name(metadata.cidx);
            return name.includes("Fixed");
        }
        
        // Add "fixed" class to cell element.
        function set_fixed_class(cellElement) {
            cellElement.classList.add(FIXED_CLASS);
        };

        // Set fixed min-width to cells when appropiate. 
        function style_listener() {
            // Use regular-table api to get all rendered th and td elements.
            const ths = table_api.get_ths();
            const tds = table_api.get_tds();
            // Iterate over all rendered cells.
            for (const cellElement of [...ths, ...tds]) {
                clear(cellElement);
                if (is_fixed(cellElement)) set_fixed_class(cellElement);
            }
        }

        window.addEventListener("DOMContentLoaded", async () => {
            // Pass data_listener function to regular-table api.
            table_api.setDataListener(data_model.data_listener);

            // Attach style_listener function to a listener to apply changes
            // after the grid is updated.
            table_api.addStyleListener(style_listener);

            // Trigger table draw method to make listeners run.
            await table_api.draw();
        });
    </script>

    <style>
        /* Set fixed width for cells. */
        .fixed {
            min-width: 100px !important;
            max-width: 100px !important;
        }
        /* Disable default header text selection. */
        thead tr th {
            user-select: none;
        }
        /* Do not allow content to overflow cell limit. */
        tr th, tr td {
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
    </style>
</body>
</html>