<!--
   
   Copyright (c) 2020, the Regular Table Authors.
   
   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../node_modules/@finos/perspective/dist/umd/perspective.js"></script>
    <script src="../dist/umd/regular-table.js"></script>
    <link rel='stylesheet' href="../dist/css/material.css">
    <style>
        .pd-align-right {
            text-align: right;
        }
        .pd-align-left {
            text-align: left;
        }

        /* Header elements that end a leaf group */
        tr td[colspan="1"], tr th[colspan="1"] {
            border-right: 1px solid #ddd;
        }

        /* Border separating frozen row-indices columns from data columns */
        tbody th:last-of-type {
            border-right: 1px solid #ddd;
        }

        regular-table tbody th:not(:last-of-type) {
            vertical-align: top;
            max-width: 40px;
            min-width: 40px;
        }


        regular-table tbody th:last-of-type {
            max-width: 100px;
            min-width: 100px;
        }

    </style>
</head>

<body>

    <regular-table></regular-table>

    <script>
        const FORMATTERS = {
            datetime: Intl.DateTimeFormat("en-us"),
            date: Intl.DateTimeFormat("en-us"),
            integer: Intl.NumberFormat("en-us"),
            float: new Intl.NumberFormat("en-us", {
                style: "decimal",
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
            }),
        };

        class PerspectiveDataModel {
            _tree_header(paths = []) {
                return paths.map((path) =>
                    path
                        .slice(0, path.length - 1)
                        .fill("")
                        .concat(path[path.length - 1])
                );
            }
        
            _format(parts, val) {
                if (val === null) {
                    return "-";
                }
                const type = this._schema[parts[parts.length - 1]] || "string";
                return FORMATTERS[type]?.format(val) || val;
            }

            async dataListener(x0, y0, x1, y1) {
                let columns = {};
                if (x1 - x0 > 0 && y1 - y0 > 0) {
                    columns = await this.view.to_columns({
                        start_row: y0,
                        start_col: x0,
                        end_row: y1,
                        end_col: x1,
                        id: this._config.row_pivots.length > 0,
                    });
                }

                const data = [];
                const column_headers = [];
                for (const path of this._column_paths.slice(x0, x1)) {
                    const path_parts = path.split("|");
                    data.push(columns[path].map((x) => this._format(path_parts, x)));
                    column_headers.push(path_parts);
                }

                return {
                    num_rows: this._num_rows,
                    num_columns: this._column_paths.length,
                    row_headers: this._tree_header(columns.__ROW_PATH__),
                    column_headers,
                    data,
                };
            }

            styleListener({detail: regularTable}) {
                for (const td of regularTable.querySelectorAll("td, thead tr:last-child th")) {
                    const metadata = regularTable.get_meta(td);
                    let type;
                    if (metadata.x >= 0) {
                        const column_path = this._column_paths[metadata.x];
                        const column_path_parts = column_path.split("|");
                        type = this._schema[column_path_parts[column_path_parts.length - 1]];
                    } else {
                        type = "string";
                    }
                    if (type === "integer" || type === "float") {
                        td.classList.toggle("pd-align-right", true);
                        td.classList.toggle("pd-align-left", false);
                        if (parseFloat(metadata.value) > 0) {
                            td.classList.add("pd-positive");
                            td.classList.toggle("pd-negative", false);
                        } else if (parseFloat(metadata.value) < 0) {
                            td.classList.add("pd-negative");
                            td.classList.toggle("pd-positive", false);
                        }
                    } else {
                        td.classList.toggle("pd-positive", false);
                        td.classList.toggle("pd-negative", false);
                        td.classList.toggle("pd-align-right", false);
                        td.classList.toggle("pd-align-left", true);
                    }
                }
            }

            async set_view(table, view) {
                this.view = view;
                this.table_schema = await table.schema();
                this._config = await view.get_config();
                this._num_rows = await view.num_rows();
                this._schema = await view.schema();
                this._column_paths = await view.column_paths();
                this._column_paths = this._column_paths.filter((path) => {
                    return path !== "__ROW_PATH__" && path !== "__ID__";
                });
            }
        }

        window.PerspectiveDataModel = PerspectiveDataModel;
    </script>
    
    <script>
        /**********************************************************************
         *
         * Example
         *
         */

        const URL = "../node_modules/superstore-arrow/superstore.arrow";
        const perspective = window.perspective;

        const datasource = async () => {
            const request = fetch(URL);
            const worker = perspective.worker();
            const response = await request;
            const buffer = await response.arrayBuffer();
            return worker.table(buffer);
        };

        window.addEventListener("DOMContentLoaded", async function () {
            const table = await datasource();
            const view = table.view({
                row_pivots: ["Region", "State", "City"],
                column_pivots: ["Category", "Sub-Category"],
                columns: ["Sales", "Profit"],
            });

            const model = new window.PerspectiveDataModel();
            await model.set_view(table, view);

            const regular = document.getElementsByTagName("regular-table")[0];
            regular.addStyleListener(model.styleListener.bind(model));
            regular.setDataListener(model.dataListener.bind(model));
            await regular.draw();
        });
    </script>

</body>

</html>