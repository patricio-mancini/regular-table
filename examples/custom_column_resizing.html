<!--
   
   Copyright (c) 2020, the Regular Table Authors.
   
   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!--

-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../dist/umd/regular-table.js"></script>
    <link rel='stylesheet' href="../dist/css/material.css">
</head>

<body>

    <regular-table></regular-table>

    <script>
        class CreateDataModel {
            constructor(baseColumns, columnCount, cellCount) {
                this._baseColumns = baseColumns;
                this._columnCount = columnCount;
                this._cellCount = cellCount;
                this._dataset = this._createDataset();
                this.columns = this._createColumns();
                this._data = this.columns.map(({key}) => this._dataset[key]);
                this._columnHeaders = this.columns.map(({value}) => [value]);
            }

            _createTextCells(text) {
                return Array.from(Array(this._cellCount).keys())
                    .map((idx) => `${text} ${idx} ${text} ${idx} ${text} ${idx}`);
            }

            _createColumns() {
                return Array.from(Array(this._columnCount)).map((_, idx) => {
                    const key = this._baseColumns[idx % this._baseColumns.length];
                    return {
                        key,
                        value: `${key} Column ${idx}`,
                    };
                });
            }

            _createDataset() {
                return this._baseColumns.reduce(
                    (prev, curr) => ({
                        ...prev,
                        [curr]: this._createTextCells(curr),
                    }),
                    {}
                );
            }

            getColumnKey(index) {
                return this.columns[index].key;
            }

            getColumnValue(index) {
                return this.columns[index].value;
            }

            dataListener = (x0, y0, x1, y1) => {
                const data = this._data.slice(x0, x1).map((col) => col.slice(y0, y1));
                const column_headers = this._columnHeaders.slice(x0, x1);
                const num_columns = this._data.length;
                const num_rows = this._data[0].length;
                return {
                    num_rows,
                    num_columns,
                    column_headers,
                    data,
                };
            };
        }
    </script>
    <script>

        const baseColumns = ["Small", "Medium", "Large"];
        const columnCount = 12;
        const cellCount = 1000;
        const columnSizes = new Map();

        // Create data model that returns a dataListener function and a columns array.
        const dataModel = new CreateDataModel(baseColumns, columnCount, cellCount);

        // Get Regular Table element.
        const tableApi = document.getElementsByTagName("regular-table")[0];

        // Clear previous cell manipulations done by this api.
        function clear(cellElement) {
            cellElement.classList.remove("small", "medium", "large");
        }

        // Add class to cell element.
        function setClass(cellElement) {
            const metadata = tableApi.getMeta(cellElement);
            const name = dataModel.getColumnKey(metadata.x);
            let className;
            if (name.includes("Small")) {
                className = "small";
            } else if (name.includes("Medium")) {
                className = "medium";
            } else if (name.includes("Large")) {
                className = "large";
            }
            cellElement.classList.add(className);
        }

        function setCustomResizeElement(th) {
            const span = document.createElement("span");
            span.classList.add("resize");
            th.appendChild(span);
        }

        async function onColumnMove(start, newX, th, idx, width, minWidth, maxWidth) {
            const diff = newX - start;
            const override_width = Math.min(maxWidth, Math.max(minWidth, width + diff));

            th.style.minWidth = override_width + "px";
            th.style.maxWidth = override_width + "px";

            const tds = tableApi.querySelectorAll("thead th, tbody td");
            for (const td of tds) {
                const tdMetadata = tableApi.getMeta(td);
                if (idx === tdMetadata.x) {
                    td.style.minWidth = override_width + "px";
                    td.style.maxWidth = override_width + "px";
                }
            }
        }

        function onColumnResize(event) {
            const start = event.pageX;
            const element = event.target.parentElement;
            const metadata = tableApi.getMeta(element);

            element.style.minWidth = "";
            element.style.maxWidth = "";

            let width, minWidth, maxWidth;

            const columnSize = columnSizes.get(metadata.x);

            if (columnSize) {
                width = columnSize.width;
                minWidth = columnSize.minWidth;
                maxWidth = columnSize.maxWidth;
            } else {
                const elementStyles = window.getComputedStyle(element);
                width = parseInt(elementStyles.getPropertyValue("width"));
                minWidth = parseInt(elementStyles.getPropertyValue("min-width"));
                maxWidth = parseInt(elementStyles.getPropertyValue("max-width"));
            }

            const move = (event) => onColumnMove(start, event.pageX, element, metadata.x, width, minWidth, maxWidth);
            const up = async (event) => {
                document.removeEventListener("mousemove", move);
                document.removeEventListener("mouseup", up);

                const diff = event.pageX - start;
                const override_width = Math.min(maxWidth, Math.max(minWidth, width + diff));

                columnSizes.set(metadata.x, {
                    minWidth,
                    maxWidth,
                    width: override_width
                });

                await tableApi.draw();
            };
            document.addEventListener("mousemove", move);
            document.addEventListener("mouseup", up);
        }

        function styleListener() {
            const ths = tableApi.querySelectorAll("thead th");
            const tds = tableApi.querySelectorAll("tbody td");
            
            for (const th of ths) {
                const metadata = tableApi.getMeta(th);
                setCustomResizeElement(th);
            }

            // Iterate over all rendered cells.
            for (const cellElement of [...ths, ...tds]) {
                clear(cellElement);
                setClass(cellElement);

                const metadata = tableApi.getMeta(cellElement);
                const columnSize = columnSizes.get(metadata.x);

                if (columnSize) {
                    width = columnSize.width;
                    minWidth = columnSize.minWidth;
                    maxWidth = columnSize.maxWidth;
                } else {
                    const elementStyles = window.getComputedStyle(cellElement);
                    width = parseInt(elementStyles.getPropertyValue("width"));
                    minWidth = parseInt(elementStyles.getPropertyValue("min-width"));
                    maxWidth = parseInt(elementStyles.getPropertyValue("max-width"));
                }

                onColumnMove(0, 0, cellElement, metadata.x, width, minWidth, maxWidth);
            }
        }

        window.addEventListener("DOMContentLoaded", async () => {
            // Pass dataListener function to regular-table api.
            tableApi.setDataListener(dataModel.dataListener);

            // Attach styleListener function to a listener to apply changes
            // after the grid is updated.
            tableApi.addStyleListener(styleListener);

            // Trigger table draw method to make listeners run.
            await tableApi.draw();

            document.addEventListener("mousedown", (event) => {
                const is_resize = event.target.classList.contains("resize");
                if (is_resize) {
                    onColumnResize(event);
                }
            });

        });
    </script>
    <style>
        .small {
            min-width: 20px;
            max-width: 100px;
        }
        .medium {
            min-width: 40px;
            max-width: 200px;
        }
        .large {
            min-width: 60px;
            max-width: 300px;
        }
        /* Disable default header text selection. */
        thead tr th {
            user-select: none;
        }
        /* Do not allow content to overflow cell limit. */
        tr th, tr td {
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .resize {
            height: 100%;
            width: 10px;
            position: absolute;
            top: 0;
            right: 0;
            cursor: col-resize;
        }
    </style>
</body>
</html>